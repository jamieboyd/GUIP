#pragma rtGlobals=3		// Use modern global access method.
#pragma IgorVersion=6
#pragma version = 1	 // Last Modified: 2016/12/01 by Jamie Boyd
//#pragma ModuleName= GUIP


// GUIPHist organizes the plotting of data in a 2D matrix on single graph with multiple sets of bottom and left axes.
// See GUIP.ihf for details


//***********************************************************************************	
//********************************CONSTANTS*******************************************	
//***********************************************************************************	
//constants for default title and axes fonts and font sizes
static strconstant kTitlefont = "Arial"
static constant kTitleFontSize = 12
static strconstant kAxisfont = "Times"
static constant kAxisfontSize = 10
// constants for default graph position
static constant kwLeft = 40
static constant kwTop = 40
static constant kwRight=560
static constant kwBottom = 360
// constants for readibility/convenience
// scaling
constant kGUIPHistFullScal =0
constant kGUIPHistLeaveScal = 1
constant kGUIPHistAutoScal =2
constant kGUIPHistProvideScal =3
// frame
constant kGUIPHistNoFrame =0
constant kGUIPHistUnderlineFrame =1
constant kGUIPHistBoxFrame =2

//***********************************************************************************	
//********************************STRUCTURES AND PROTOTYPE******************************	
//***********************************************************************************	
// The structure used in GUIPHist()
// Last Modified: 2013/03/19 by Jamie Boyd
STRUCTURE GUIPHistStruct
	variable isAppending // if non zero, append data to an existing  graph, else make a new graph
	string graphName // NAME (not title) of graph to make or append to. If no name for a new graph, name will be GUIP_Hist. For appending, "" means append to top window
	string graphTitle  // desired TITLE (not name) for the graph. If no title, title will be "GUIP Hist" for a new graph, unchanged for appending
	variable killBehavior // if making a new graph, kill behavior when closed, as defined by Display/k=killBehavior
	//k =0:	Normal with dialog (default).
	//k =1:	Kills with no dialog.
	//k =2:	Disables killing.
	//k =3:	Hides the window.
	variable nHists // the number of individual histograms to plot. Maximum is100
	STRUCT GUIPHistCS contentStructs [100]
	FUNCREF GUIPHistAddProto addContent  // call back function to add content to each histogram
	variable wLeft // if making a new graph, left position of main graph
	variable wTop // if making a new graph, top position of main graph
	variable wBottom // if making a new graph, right position of main graph
	variable wRight // if making a new graph, bottom position of main graph
	variable  margL, margT, margR, margB // if making a new graph, margins for the whole graph, in points
	variable useProvAxesPos // 1 to use provided axis positions when plotting, else generated by order of listing in content structs
	variable FirstGoAcross //if non-zero, waves are first plotted row-by-row, from top to bottom, else column-by-column from left to right
	variable nLaxes //number of left axes requested for the plot - max is 100
	variable LaxisOffset // if appending to new axes, offset for left axis number
	string lAxesLegends [100] // optional legend string for each left axis 
	variable nBAxes // number of bottom axes requested for the plot. max is 100
	string bAxesLegends [100] // optional legend string for each bottom axis 
	variable BaxisOffset // if appending to new axes, offset for bottom axis numbe
	string axisfont // font for the axes, default is Arial
	variable axisFontSize // font size for the  axes, default is 10
	variable spacerPercentX, spacerPercentY //Percent of total graph width/height that is used as space beteeen axes. 1% is a good value
	variable xScalType, yScalType // 0 means scale to min/max of all the hists(plus max and min of axes already plotted, if appending).
	//1 means "don't change axis max/min", use when appending, or when setting your own values in a plot function
	// 2 means autoscale, leave axes free to roam
	// 3 means use provided min and max values for axes
	variable minX, minY, maxX, maxY // axes mins and maxs to use for each plot. 
	variable axesOffsetX, axesOffsetY // offset of data from left and bottom axes, in percent, of axis range, for both left and bottom. default is 0, i.e., data go right to the edge of the axes
	// This only makes sense when graphs are scaled to show all data, otherwise axesOffset willl be ignored
	string titlefont // font for the titles, default is Arial
	variable titleFontSize // font size for the  titles, default is 10
	variable frame// 0 for no frame, 1 for underline, 2 for a box
EndStructure	
	
//***********************************************************************************	
// The structure that holds content for a single plot
// Last Modified: 2013/03/19 by Jamie Boyd
STRUCTURE GUIPHistCS
	// Window name, from enclosing GUIPHistStruct
	string graphName
	// which axes positions to use will be generated by GUIPHist by the order in which the content structs are added
	// unless useProvAxesPos is set, in which case the contentStruct must provide the axes to use
	variable lAxis // which number of left axis to use
	variable bAxis // which number of bottom axis to use
	string lAxisStr // name of left axis,"L_" + num2str (laxis)
	string bAxisStr // name of bottom axis,"L_" + num2str (baxis)
	// Data you provide to GUIPHist about this histogram, and is available to your callback function for plotting
	string histTitle // Optional title for this histogram.
	// GUIPHist will name the textbox with combo of bottom and left axes names and will be able to identify them to
	// move them to the corrrect location.
	variable nUserWaves // number of waves used, maximum is 32
	WAVE userWaves [32] // waves to do what you want with
	variable nUserStrings // number of strings used, maximum is 32
	string userStrings [32] // strings to do what you want with
	variable nUserVariables // number of variables used, maximum is 32
	variable userVariables [32] // variables to do what you want with
	variable nUserGlobalVars
	NVAR userGlobalVars [32]
	variable nUserGlobalStrs
	SVAR userGlobalStrs [32]
endstructure

//***********************************************************************************	
// a function prototype for the plotting callback function
// Last Modified May 12 2010 by Jamie Boyd
Function GUIPHistAddProto (s)
	STRUCT GUIPHistCS &s
end

//***********************************************************************************	
//*****************************MAIN FUNCTION*******************************************	
//***********************************************************************************	
// Makes a GUIPHist-style plot
// Last Modified: 2013/03/19 by Jamie Boyd
Function GUIPHist (s)
	STRUCT GUIPHistStruct &s
	// Set some defaults for missing values
	string fontSizeStr
	if (s.titleFontSIze == 0)
		s.titleFontSIze = kTitleFontSize
	endif
	if (cmpstr (s.titleFont, "" ) ==0)
		s.titleFont = kTitleFont
	endif
	if (s.axisFontSize == 0)
		s.axisFontSize = kAxisfontSize
	endif
	if (cmpstr (s.AxisFont, "" ) ==0)
		s.AxisFont =kAxisfont
	endif	
	//if making a new graph, display an empty graph with requested title and name and position
	if (s.isAppending==0)
		// check position
		if ((s.wRight) ==0 || (s.wBottom == 0))
			s.wLeft = kwLeft
			s.wTop = kwTop
			s.wRight=kwRight
			s.wBottom = kwBottom
		endif
		// check name
		if (cmpstr (s.graphName, "") == 0)
			s.graphName = "GUIP_Hist"
		else
			s.graphName = cleanupname (s.graphName , 0)
		endif
		// check title
		if (cmpStr (s.graphTitle, "" )== 0)
			s.graphTitle =  "GUIP Hist"
		endif
		display/N=$s.graphName/W=(s.wLeft,s.wTop,s.wRight,s.wBottom )/K=(s.KillBehavior) as s.graphTitle
		s.graphName = S_name //name of the graph that was made, as requested name may be postfixed with a numeral
	else // appending. check that requested graph exists
		if (cmpstr (s.graphName, "") == 0) // appending to top graph, just make sure there is a graph
			if (itemsinlist (WinList("*", ";", "WIN:1" )) == 0)
				doAlert 0, "GUIPHist error: There are no graphs open to append to."
				return 1
			endif
		else // Appending to a given graph - make sure it exists	
			if (cmpStr (s.graphName, stringfromlist (0, winlist (s.graphName, ";", "WIN:1"),";")) != 0)
				doalert 0, "GUIPHist error: The graph selected to append to, \"" + s.graphName + "\", does not exist and thus can not be appended to."
				return 1
			endif		
		endif
	endif
	// Plot, and add textbox titles
	string condtag, textName, Laxis, Baxis
	fontSizeStr = num2str (s.titleFontSIze)
	if (s.titleFontSIze < 10)
		fontSizeStr = "0" + fontSizeStr
	endif
	variable iHist
	For (iHist = 0; iHist < s.nHists; iHist += 1)
		// which axes combination to use?
		if (s.useProvAxesPos ==0)  // making them up as we go along. Tell ploting struct which axes to use. Otherwise, plotting struct tells GUIPHist which axes to use
			if (s.firstGoAcross)
				s.contentStructs[iHist].Laxis =  floor (iHist/s.nBaxes) //down the column varies slowly
				s.contentStructs[iHist].Baxis = s.LaxisOffset + mod (iHist, s.nBaxes) //across the row varies quickly
			else 
				s.contentStructs[iHist].Laxis = mod (iHist, s.nLaxes)
				s.contentStructs[iHist].Baxis =  floor (iHist/s.nLaxes) 
			endif
		else
			
		endif
		Laxis = "L_" + 	num2str (s.contentStructs[iHist].Laxis + s.LaxisOffset )	
		Baxis = "B_" +  num2str (s.contentStructs[iHist].Baxis + s.BaxisOffset )
		s.contentStructs[iHist].LaxisStr = Laxis
		s.contentStructs[iHist].BaxisStr = Baxis
		// set the graph name in the content struct from the graph name
		s.ContentStructs[ihist].graphName = s.graphName 
		// call the plotting function
		s.addContent(s.contentStructs [ihist])
		// add a title, if requested
		if (cmpStr (s.contentStructs[iHist].histTitle, "" ) != 0)
			// make name up based on the axes pair
			textName = Laxis + "y" + Baxis
			// make the formatted string to display the text
			condtag =  "\\Z" + fontSizeStr + "\\F'" + s.titleFont + "'\K(0,0,0) " + s.contentStructs[iHist].histTitle
			// append in default location
			if (s.nBaxes == 1) // if only 1 X axis, center title (MT for Middle Top), horizontal offset = 0
				textbox /w=$s.graphName/N= $(textName)/B=1/F=0/A=MT/L=0  condtag
			else
				textbox /w=$s.graphName/N= $(textName)/B=1/F=0/A=LT/L=0 condtag
			endif
		endif
	endfor
	doupdate
	// set axis ranges
	GUIPHistSetAxis (s)
	// set axis labels and sizes
	GUIPHistSetLabels (s)
	// Reposition elements
	GUIPHistPositionAAF(s.graphName, s.spacerPercentX, s.spacerPercentY, s.frame)
	// set margins
	ModifyGraph /w= $s.graphName margin(left)=s.margL, margin (top) =s.margT, margin (right) = s.margR, margin (bottom) = s.margB
end

//***********************************************************************************	
//*****************************STATIC UTILITY FUNCTIONS***********************************	
//***********************************************************************************	
// Sets Min and Max for axes
// Last Modified: 2013/03/19 by Jamie Boyd
static Function GUIPHistSetAxis (s)
	STRUCT GUIPHistStruct &s
	
	string Laxis, leftAxes, Baxis, bottomAxes
	variable iHist, iAx
	variable nLaxes, nBaxes
	//Left axes
	// if scaling to provided values, or autoscaling, just modify provided axes
	if ((s.YScalType == kGUIPHistAutoScal) || (s.YScalType == kGUIPHistProvideScal))
		leftAxes = ""
		For (iHist = 0; iHist < s.nHists; iHist += 1)
			Laxis = "L_" +  num2str (s.contentStructs[iHist].Laxis + s.LaxisOffset)
			if (whichListItem (Laxis, leftAxes, ";") == -1)
				leftAxes += Laxis + ";"
			endif
		endfor
		nLaxes = itemsinList (leftAxes, ";")
		if (s.YScalType == kGUIPHistAutoScal)
			for (iAx =0; iAx < nLaxes; iAx +=1)
				Laxis = stringfromList (iAx, leftAxes, ";")
				setAxis/w=$s.graphName/A $Laxis
			endfor
		else
			for (iAx =0; iAx < nLaxes; iAx +=1)
				Laxis = stringfromList (iAx, leftAxes, ";")
				SetAxis/w=$s.graphName $Laxis  s.minY, s.MaxY
			endfor
		endif
	elseif  (s.YScalType == kGUIPHistFullScal)
		// look at all axes to find global min and max
		leftAxes = GUIPHistGetLeftAxes (s.graphName)
		nLaxes = itemsinList (leftAxes, ";")
		s.minY = INF
		s.maxY = -INF
		for (iAx =0; iAx <  s.nLaxes; iAx += 1)
			Laxis = stringFromList (iAx, leftAxes, ";")
			GetAxis/Q/w=$s.graphName $Laxis
			s.minY = min (V_min, s.minY)
			s.maxY = max (V_max, s.maxY)
		endfor
		// Loop through the set of left axes to set provided max,min
		variable lOffset = ((s.maxY - s.minY) * s. axesOffsetY * 0.01)
		for (iAx =0; iAx < s.nLaxes; iAx += 1)
			Laxis = stringFromList (iAx, leftAxes, ";")
			if (s.yScalType != kGUIPHistAutoScal)
				SetAxis/w=$s.graphName $Laxis  (s.minY - lOffset), (s.maxY + lOffset)
			endif
		endfor
	endif
	// Bottom axes
	// if scaling to provided values, or autoscaling, just modify provided axes
	if ((s.XScalType == kGUIPHistAutoScal) || (s.XScalType == kGUIPHistProvideScal))
		bottomAxes = ""
		For (iHist = 0; iHist < s.nHists; iHist += 1)
			Baxis = "B_" + 	num2str (s.contentStructs[iHist].Baxis + s.BaxisOffset)	
			if (whichListItem (Baxis, bottomAxes, ";") == -1)
				bottomAxes += Baxis + ";"
			endif
		endfor
		nBaxes = itemsinList (bottomAxes, ";")
		if (s.xScalType == kGUIPHistAutoScal)
			for (iAx =0; iAx < nBaxes; iAx +=1)
				Baxis = stringfromList (iAx, bottomAxes, ";")
				setAxis/w=$s.graphName/A $Baxis
			endfor
		else
			for (iAx =0; iAx < nBaxes; iAx +=1)
				Baxis = stringfromList (iAx, bottomAxes, ";")
				SetAxis/w=$s.graphName $Baxis  s.minX, s.MaxX
			endfor
		endif
	elseif (s.xScalType == kGUIPHistFullScal)
		bottomAxes = GUIPHistGetBottomAxes (s.graphName)
		nBaxes =itemsinList (bottomAxes, ";")
		s.minX = INF
		s.maxX = -INF
		for (iAx =0; iAx <  nBaxes; iAx += 1)
			Baxis = stringFromList (iAx, bottomAxes, ";")
			GetAxis/Q/w=$s.graphName $Baxis 
			s.minX = min (V_min, s.minX)
			s.maxX = max (V_max, s.maxX)
		endfor
		variable boffset = ((s.maxX - s.minX) * s.axesOffsetX *0.01)
		for (iAx =0; iAx < nBaxes; iAx += 1)
			Baxis = stringFromList (iAx, bottomAxes, ";")
			SetAxis/w=$s.graphName $Baxis  (s.minX -boffset), (s.maxX + boffset)
		endfor
	endif
end

// **********************************************************************************************
// Sets font sizes and labels for axes
// Last Modified: 2013/03/19 by Jamie Boyd
static Function GUIPHistSetLabels (s)
	STRUCT GUIPHistStruct &s
	
	// set font size string
	string fontSizeStr = num2str (s.axisFontSize)
	if (s.axisFontSize < 10)
		fontSizeStr = "0" + fontSizeStr
	endif
	string axisLabelStr, Laxis, Baxis
	variable iAx, nAx
	for (iAx = 0;  iAx < s.nLaxes; iAx += 1)
		Laxis = "L_" + num2str (iAx + s.LaxisOffset)
		ModifyGraph/w= $s.graphName fSize($Laxis)=s.axisFontSize
		axisLabelStr =  s.lAxesLegends [iAx]
		if (cmpstr (axisLabelStr, "") != 0)
			ModifyGraph/w= $s.graphName lblPosMode($Laxis)=1
			if (cmpstr (axisLabelStr, "") == 0)
				axisLabelStr = "\\U"
			endif
			label/w= $s.graphName, $Laxis  "\\Z" + fontSizeStr + "\\F'" + s.axisFont + "'"  + axisLabelStr
			execute "ModifyGraph/w=" + s.graphName + " font(" +Laxis + ") ='" + s.AxisFont + "'"
		endif
	endfor
	for (iAx =0 ; iAx < s.nBaxes; iAx += 1)
		Baxis = "B_" + num2str (iAx + s.BaxisOffset)
		ModifyGraph /w= $s.graphName fSize($Baxis)=s.axisFontSize
		axisLabelStr =  s.BaxesLegends [iAx]
		if (cmpstr (axisLabelStr, "") != 0)
			ModifyGraph/w= $s.graphName lblPosMode($Baxis)=1
			if (cmpstr (axisLabelStr, "") == 0)
				axisLabelStr = "\\U"
			endif
			label /w= $s.graphName, $Baxis  "\\Z" + fontSizeStr + "\\F'" + s.axisFont + "'"  + axisLabelStr
			execute "ModifyGraph/w=" + s.graphName + " font(" +Baxis + ") ='" + s.AxisFont + "'"
		endif
	endfor
end

//***********************************************************************************	
//apportions axes, annotations, and frames for a GUIPHist graph
// Last Modified 2013/04/24 by Jamie Boyd
static Function GUIPHistPositionAAF(graphName, spacerPercentX, spacerPercentY, frame)
	string graphName
	variable spacerPercentX
	variable spacerPercentY
	variable frame // 0 =noFrame, 1 = underline, 2 =box
	
	// Get sorted list of left and right axes
	string leftAxes = GUIPHistGetLeftAxes (graphName)
	variable nLaxes = itemsinList (leftAxes)
	string bottomAxes = GUIPHistGetBottomAxes (graphName)
	variable nBaxes = itemsInList (bottomAxes)
	//  reapportion space
	variable spacerPropX = spacerPercentX/100
	variable spacerPropY = spacerPercentY/100
	variable bottomProp = (1- ((nBaxes -1) * spacerPropX))/nBaxes
	variable leftProp = (1- ((nLaxes -1) * spacerPropY))/nLaxes
	variable iAx, BaxisLeft, BaxisRight, LaxisBottom, LaxisTop
	string anAxis
	for (iAx =0; iAx < nLaxes; iAx += 1)
		anAxis = stringFromList (iAx, leftAxes, ";")
		LaxisTop =  min (1, 1 - (iAx * (leftProp + spacerPropY)))
		LaxisBottom =max (0, LaxisTop - leftProp)
		ModifyGraph/w=$graphName axisEnab($anAxis)={LaxisBottom, LaxisTop}
		// set free axis position to leftmost
		ModifyGraph freePos($anAxis)={0,kwFraction}
		// Personal preference for tick length and thickness. Could make these settable, I suppose
		ModifyGraph/w=$graphName btLen($anAxis)=2,btThick($anAxis)=1 
	endfor
	for (iAx =0; iAx < nBaxes; iAx += 1)
		anAxis = stringFromList (iAx, bottomAxes, ";")
		BaxisLeft = max (0, iAx * (bottomProp + SpacerPropX))
		BaxisRight =min (1, BaxisLeft + bottomProp)
		ModifyGraph/w=$graphName axisEnab($anAxis)={BaxisLeft,BaxisRight}
		// set free axis position to leftmost
		ModifyGraph freePos($anAxis)={0,kwFraction}
		// Personal preference for tick length and thickness. Could make these settable, I suppose
		ModifyGraph/w=$graphName btLen($anAxis)=2,btThick($anAxis)=1 
	endfor
	// Get rid of orphaned annotations named by GUIPHist
	// annotations named by GUIPHist are named by left axis and bottom axis, separated by "y" L_0yB_0
	string anAN, anAnL, anAnB, Anlist =  AnnotationList(graphName)
	variable iAn, nAns = itemsinList (anList, ";")
	for (iAN =0; iAn < nAns; iAn += 1)
		anAn = stringFromList (iAn, anList, ";")
		anAnL = stringFromList (0, anAn, "y")
		anAnB = stringFromList (1, anAn, "y")
		if (((cmpStr (anAnL [0,1], "L_") ==0) && (cmpStr (anAnB[0,1], "B_") == 0)) &&((WhichListItem(anAnL, leftAxes , ";") == -1) || (WhichListItem(anAnB, BottomAxes , ";") == -1)))
			TextBox/K/N=$anAN
		endif
	endfor
	// Adjust annotation position and If needed, redraw the frames
	variable iLax, iBax, yTboxOffset, xtBoxOffset
	string baxis, laxis
	// kill previous Frame drawing
	SetDrawLayer/w=$graphName ProgBack
	DrawAction/w=$graphName getgroup=GUIPHist, delete, begininsert
	SetDrawEnv/w=$graphName gstart,gname= GUIPHist
	for (iBax =0; iBax < nBaxes; iBax += 1)
		baxis = stringfromlist (iBax, bottomAxes, ";")
		for (iLax =0; iLax < nLaxes; iLax += 1)
			laxis = stringfromlist (iLax, leftAxes, ";")
			// redraw frame
			if (frame != kGUIPHistNoFrame)
				SetDrawEnv/w=$graphName fillpat= 0
				SetDrawEnv/w=$graphName xcoord= prel,ycoord= prel
				BaxisLeft = iBax * (bottomProp + SpacerPropX)
				BaxisRight =BaxisLeft + bottomProp
				LaxisBottom = 1 - (iLax * (leftProp + SpacerPropY))
				LaxisTop =LaxisBottom - leftProp
				if (frame == kGUIPHistUnderlineFrame)
					DrawLine/w=$graphName BaxisLeft , LaxisBottom, BaxisRight, LaxisBottom // each histogram underlined
				elseif (frame == kGUIPHistBoxFrame)
					DrawRect/w=$graphName BaxisLeft, LaxisBottom, BaxisRight , LaxisTop  // a neat little box around each histogram
				endif
			endif
			// readjust annotation position
			anAn = Laxis + "y" + baxis
			if (WhichListItem(anAn, Anlist, ";") > -1)
				yTboxOffset = ((iLax  * leftProp) + ((iLax - 0.95)  * SpacerPropY))  * 100
				xtBoxOffset = (iBax + 0.25) * (bottomProp + SpacerPropX) * 100
				if (nBaxes == 1) // if only 1 X axis, center title (MT for Middle Top), horizontal offset = 0
					textbox /C/w=$graphName/N= $(anAN)/B=1/F=0/A=MT/L=0/x=(0)/y=(yTboxOffset)
				else
					TextBox/C/w=$graphName/N=$anAN/F=0/X=(xtBoxOffset)/Y=(ytBoxOffset)
				endif
			endif
		endfor
	endfor
	SetDrawEnv/w=$graphName gstop
	DrawAction/w=$graphName endinsert
	SetDrawLayer/w=$graphName UserFront
end

// **********************************************************************************************
// Returns a list of all Left axes
// Last Modified: 2013/03/19 by Jamie Boyd
Function/S GUIPHistGetLeftAxes (graphName)
	string graphName
	
	String anAxis, leftAxes = "", allAxes = AxisList(graphName)
	variable iAxis, nAxes = itemsinlist (allAxes, ";")
	for (iAxis =0 ; iAxis < nAxes; iAxis += 1)
		anAxis = stringFromList (iAxis, allAxes, ";")
		if (cmpStr (anAxis [0,1],"L_") == 0)
			leftAxes += anAxis + ";"
		endif
	endfor
	return sortList (leftAxes, ";", 16)
end

// **********************************************************************************************
// Returns a list of all bottom axes
// Last Modified: 2013/03/19 by Jamie Boyd
Function/S GUIPHistGetBottomAxes (graphName)
	string graphName
	
	String anAxis, bottomAxes="", allAxes = AxisList(graphName)
	variable iAxis, nAxes = itemsinlist (allAxes, ";")
	for (iAxis =0 ; iAxis < nAxes; iAxis += 1)
		anAxis = stringFromList (iAxis, allAxes, ";")
		if (cmpStr (anAxis [0,1],"B_") == 0)
			bottomAxes += anAxis + ";"
		endif
	endfor
	return sortList (bottomAxes, ";", 16)
end


//***********************************************************************************	
//**********************************MENUS********************************************
//***********************************************************************************	
// Use these graph marquee functions in place of normal shrink and expand in a GUIP Hist plot
Menu "GraphMarquee"
	subMenu "GUIP Hist" 
		"Expand", /Q, GUIPHistExpand ()
		"Horiz Expand",/Q,GUIPHistHorizExpand()
		"Vert Expand",/Q, GUIPHistVertExpand()
		"Shrink", /Q, GUIPHistShrink ()
		"Horiz Shrink",/Q,GUIPHistHorizShrink()
		"Vert Shrink",/Q, GUIPHistVertShrink()
	end
end

//***********************************************************************************	
// Use these graph menu functions in place of normal setaxis/A in a GUIP Hist plot
Menu "Graph"
		submenu "GUIPHist"
		"AutoScale Axes/O1",/Q, GUIPHistSlashA ()
		"AutoScale Horizontal Axes/O2",/Q, GUIPHistSlashAHoriz ()
		"AutoScale Vertical Axes/O3",/Q, GUIPHistSlashAVert()
		"Set Axes/O4",/Q, GUIPHistSetAxesMenu()
	end
end

//***********************************************************************************	
// Puts up a dialog for user to set min and max for bottom and left axis ranges
Function GUIPHistSetAxesMenu ()
	variable doLeft, V_Left, V_Right, doBottom, V_Bottom, V_Top
	// set initial values
	GetAxis/Q B_0
	if (V_Flag)
		Abort "This graph does not appear to be using GUIP Hist"
	endif
	V_Left = V_min
	V_Right = V_max
	GetAxis/Q L_0
	V_Bottom = V_min
	V_Top = V_max
	Prompt doBottom, "Set Bottom Axis Range?", popup, "Yes;No"
	Prompt V_Left, "Bottom Axis Min Value"
	Prompt V_Right, "Bottom Axis Max Value"
	Prompt doLeft, "Set Left Axis Range?", popup, "Yes;No"
	Prompt V_Bottom, "Left Axis Min Value"
	Prompt V_Top, "Left Axis Max Value"
	doPrompt/Help = "Enter new values for left and right axes ranges." "Set Axes Ranges", doBottom, doLeft, V_Left, V_Bottom, V_Right, V_Top
	if (!V_Flag)
		V_Bottom = doLeft ==1 ? V_Bottom : NaN
		V_Top = doLeft ==1 ? V_Top : NaN
		V_Left = doBottom ==1 ? V_Left : NaN
		V_Right = doBottom ==1 ? V_Right : NaN
		GUIPHistSetAxes (V_Left, V_Right, V_Bottom, V_Top)
	endif
end

//***********************************************************************************	
// Directly sets Axes ranges for all plots
Function GUIPHistSetAxes (V_Left, V_Right, V_Bottom, V_Top, [win])
	variable V_Left, V_Right
	variable V_Bottom, V_Top
	string Win
	
	if (ParamIsDefault  (win))
		win = stringfromlist (0, WinList("*", ";", "WIN:1"), ";")
	endif
	string anAxis, axesList
	variable iAxis, nAxes
	if ((NumType (V_Left) ==0) && (NumType(V_Right) ==0))
		axesList = GUIPHistGetBottomAxes ("")
		naxes = itemsInList (axesList)
		for (iAxis =0;iAxis < naxes; iAxis += 1)
			anAxis = stringFromList (iAxis, axesList, ";")
			setAxis/W=$win $anAxis, V_Left, V_Right
		endfor
	endif
	if ((NumType (V_Bottom) ==0) && (NumType(V_top) ==0))
		axesList = GUIPHistGetLeftAxes ("")
		naxes = itemsInList (axesList)
		for (iAxis =0;iAxis < naxes; iAxis += 1)
			anAxis = stringFromList (iAxis, axesList, ";")
			setAxis/W=$win $anAxis, V_Bottom, V_top
		endfor
	endif
end
//***********************************************************************************	
//Marquee function to expand the axes of GuipHist plots
// Last Modified: 2013/04/24 by Jamie Boyd
Function GUIPHistExpand ()
	
	// Get sorted list of left and bottom axes
	string leftAxes = GUIPHistGetLeftAxes ("")
	variable nLaxes = itemsinList (leftAxes)
	string bottomAxes = GUIPHistGetBottomAxes ("")
	variable nBaxes = itemsInList (bottomAxes)
	getWIndow kwTopWin pSize
	variable xGraphSize = (V_Right - V_left)/nBaxes
	variable xGraphStart = V_left
	variable yGraphSize = (V_Bottom - V_Top)/nLaxes
	variable yGraphStart = V_Top
	GetMarquee
	variable yPos = floor((((V_bottom  + V_Top)/2) - yGraphStart)/yGraphSize)
	variable xPos = floor((((V_right  + V_Left)/2) - xGraphStart)/xGraphSize)
	string Laxis = stringfromlist (yPos, leftAxes, ";")
	string Baxis = stringfromlist (xPos, bottomAxes, ";")
	// Now get the marquee knowing which axes to use
	GetMarquee /K/z $Laxis, $Baxis
	// set the axes
	GUIPHistSetAxes (V_Left, V_Right, V_Bottom, V_Top, win = S_MarqueeWin)
end

//***********************************************************************************	
//Marquee function to expand only the horizontal axes of GuipHist plots
// Last Modified: 2013/04/24 by Jamie Boyd
Function GUIPHistHorizExpand ()
	
	// Get sorted list of bottom axes
	string bottomAxes = GUIPHistGetBottomAxes ("")
	variable nBaxes = itemsInList (bottomAxes)
	getWIndow kwTopWin pSize
	variable xGraphSize = (V_RIght - V_left)/nBaxes
	variable xGraphStart = V_left
	GetMarquee
	variable xPos = floor((((V_right  + V_Left)/2) - xGraphStart)/xGraphSize)
	string Baxis = stringfromlist (xPos, bottomAxes, ";")
	// Now get the marquee knowing which axes to use
	GetMarquee /K/z $Baxis
	// set the axes
	GUIPHistSetAxes (V_Left, V_Right, Nan, Nan, win = S_MarqueeWin)
end

//***********************************************************************************	
//Marquee function to expand only the vertical axes of GuipHist plots
// Last Modified: 2013/04/24  by Jamie Boyd
Function GUIPHistVertExpand ()
	// Get sorted list of left axes
	string leftAxes = GUIPHistGetLeftAxes ("")
	variable nLaxes = itemsinList (leftAxes)
	getWIndow kwTopWin pSize
	variable yGraphSize = (V_Bottom - V_Top)/nLaxes
	variable yGraphStart = V_Top
	GetMarquee
	variable yPos = floor((((V_bottom  + V_Top)/2) - yGraphStart)/yGraphSize)
	string Laxis = stringfromlist (yPos, leftAxes, ";")
	// Now get the marquee knowing which axes to use
	GetMarquee /K/z $Laxis
	GUIPHistSetAxes (Nan, Nan, V_Bottom, V_Top, win = S_MarqueeWin)
end

//***********************************************************************************	
//Marquee function to shrink the axes of GuipHist plots
// Last Modified: 2013/03/19 by Jamie Boyd
Function GUIPHistShrink ()

	// which pair of axes contains the click?
	// Get sorted list of left and bottom axes
	string leftAxes = GUIPHistGetLeftAxes ("")
	variable nLaxes = itemsinList (leftAxes)
	string bottomAxes = GUIPHistGetBottomAxes ("")
	variable nBaxes = itemsInList (bottomAxes)
	getWIndow kwTopWin pSize
	variable xGraphSize = (V_Right - V_left)/nBaxes
	variable xGraphStart = V_left
	variable yGraphSize = (V_Bottom - V_Top)/nLaxes
	variable yGraphStart = V_Top
	GetMarquee
	variable yPos = floor((((V_bottom  + V_Top)/2) - yGraphStart)/yGraphSize)
	variable xPos = floor((((V_right  + V_Left)/2) - xGraphStart)/xGraphSize)
	string Laxis = stringfromlist (yPos, leftAxes, ";")
	string Baxis = stringfromlist (xPos, bottomAxes, ";")
	// Now get the marquee knowing which axes to use
	GetMarquee /K/z $Laxis, $Baxis
	// get current max and min for these axes and calculate proportional expansion
	GetAxis/q $Baxis
	variable axRange = (V_max - V_min)* ((V_max - V_min)/(V_right - V_left))/2
	variable axCenter= V_left +  (V_right-V_left)/2 
	Getaxis/q $Laxis
	variable ayRange = (V_max - V_min)* ((V_max - V_min)/(V_top- V_bottom))/2
	variable ayCenter = V_bottom + (V_top - V_bottom)/2
	variable left = axCenter-axRange
	variable right =  axCenter + axRange
	variable bottom = ayCenter-ayRange
	variable top = ayCenter + ayRange
	// set the axes
	GUIPHistSetAxes (Left, right, bottom, top, win = S_MarqueeWin)
end

//***********************************************************************************	
//Marquee function to shrink just the vertical axes of GuipHist plots
// Last Modified: 2013/03/19 by Jamie Boyd
Function GUIPHistHorizShrink ()

	// which bottom axes contains the click?
	// Get sorted list of left and bottom axes
	string leftAxes = GUIPHistGetLeftAxes ("")
	variable nLaxes = itemsinList (leftAxes)
	string bottomAxes = GUIPHistGetBottomAxes ("")
	variable nBaxes = itemsInList (bottomAxes)
	getWIndow kwTopWin pSize
	variable xGraphSize = (V_RIght - V_left)/nBaxes
	variable xGraphStart = V_left
	GetMarquee
	variable xPos = floor((((V_right  + V_Left)/2) - xGraphStart)/xGraphSize)
	string Baxis = stringfromlist (xPos, bottomAxes, ";")
	// Now get the marquee knowing which axes to use
	GetMarquee /K/z  $Baxis
	// get current max and min for these axes and calculate proportional expansion
	GetAxis/q $Baxis
	variable axRange = (V_max - V_min)* ((V_max - V_min)/(V_right - V_left))/2
	variable axCenter= V_left +  (V_right-V_left)/2 
	variable left = axCenter-axRange
	variable right =  axCenter + axRange
	// set the axes
	GUIPHistSetAxes (left, right, NaN, NaN, win = S_MarqueeWin)
end

//***********************************************************************************	
//Marquee function to shrink the axes of GuipHist plots
// Last Modified: 2013/03/19 by Jamie Boyd
Function GUIPHistVertShrink ()

	// which pair of axes contains the click?
	// Get sorted list of left and bottom axes
	string leftAxes = GUIPHistGetLeftAxes ("")
	variable nLaxes = itemsinList (leftAxes)
	getWIndow kwTopWin gSize
	variable yGraphSize = (V_Bottom - V_Top)/nLaxes
	variable yGraphStart = V_Top
	GetMarquee
	variable yPos = floor((((V_bottom  + V_Top)/2) - yGraphStart)/yGraphSize)
	string Laxis = stringfromlist (yPos, leftAxes, ";")
	// Now get the marquee knowing which axes to use
	GetMarquee /K/z $Laxis
	// get current max and min for these axes and calculate proportional expansion
	Getaxis/q $Laxis
	variable ayRange = (V_max - V_min)* ((V_max - V_min)/(V_top- V_bottom))/2
	variable ayCenter = V_bottom + (V_top - V_bottom)/2
	variable bottom = ayCenter-ayRange
	variable top = ayCenter + ayRange
	// set the axes
	GUIPHistSetAxes (NaN, NaN, bottom, top, win = S_MarqueeWin)
end

//***********************************************************************************	
//function to set left and bottom axes to show all data on all left and bottom axes
// Last Modified: 2013/03/25 by Jamie Boyd
Function GUIPHistSlashA ()

	 GUIPHistSlashAHoriz ()
	 GUIPHistSlashAVert ()
end

//***********************************************************************************	
//function to set bottom axes to show all data on all bottom axes.
// Last Modified: 2013/03/25 by Jamie Boyd
Function GUIPHistSlashAHoriz ()

	// Get sorted list of left axes
	string bottomAxes = GUIPHistGetBottomAxes ("")
	variable nBaxes = itemsInList (bottomAxes)
	// get global max and min for all bottom axes
	variable iAxis, bMin = INF, bMax = -INF
	string baxis
	for (iAxis =0;iAxis < nBaxes; iAxis += 1)
		Baxis =  stringFromList (iAxis, bottomAxes, ";")
		setaxis/A $Baxis;doupdate
		getaxis /Q $Baxis
		bMin = min (V_min, bMin)
		bMax = max (V_max, bMax)
	endfor
	// set all bottom axes to found max and min
	GUIPHistSetAxes (bMin, bMax, NaN, NaN)
end

//***********************************************************************************	
//function to set left axes to show all data on all left axes
// Last Modified: 2013/03/25 by Jamie Boyd
Function GUIPHistSlashAVert ()

	// Get sorted list of left axes
	string leftAxes = GUIPHistGetleftAxes ("")
	variable nLaxes = itemsInList (leftAxes)
	// get global max and min for all left axes
	variable iAxis, lMin = INF, lMax = -INF
	string Laxis
	for (iAxis =0;iAxis < nLaxes; iAxis += 1)
		Laxis =  stringFromList (iAxis, leftAxes, ";")
		setaxis/A $laxis;doupdate
		getaxis /Q $Laxis
		lMin = min (V_min, lMin)
		lMax = max (V_max, lMax)
	endfor
	// set all left axes to found max and min
	GUIPHistSetAxes (NaN, NaN, lMin, lMax)
end


//***********************************************************************************	
//*****************************TESTING************************************************	
//***********************************************************************************	
// A test function that demonstrates the use of GUIPHist
// Last modified 2013/03/19 by Jamie Boyd
Function GUIPHist_test (nX, nY)
	variable nX   	// number of bottom (horizontal) axes
	variable nY   // number of left (vertical) axes
	
	// Declare a Hist Struct and a content struct for plotting with GUIPHist
	STRUCT GUIPHistStruct s
	STRUCT GUIPHistCS cs
	// fill "non-array" parts of GUIPHistStruct s
	// i.e., those that do not need to be filled inside of a loop
	s.isAppending = 0						// making a new plot, not appending
	s.graphName = "GUIPHist"			// Requested name of the new graph will be GUIPHist
	s.graphTitle = "GUIP Test Graph"	// Title of the new graph will be "GUIP Test Graph"
	s.killBehavior = 0					// new graph will kill with no dialog
	s.nHists= (nX * nY)					// The total number of plots is nX times nY
	// Make a function reference to the user function to add content, GUIPHist_test_Add (see below)
	FUNCREF GUIPHistAddProto s.addContent = GUIPHist_test_Add
	// Define onscreen position for window for new graph. Here, left =10 and right = 600,
	// top = 50, and bottom = 350, so window size = 590 x 300
	s.wLeft = 10
	s.wTop = 50
	s.wRight = 600
	s.wBottom = 350
	// Use auto margins. This is the default, so explicitly setting them is not needed
	s.margL = 0
	s.margT = 0
	s.margR = 0
	s.margB = 0
	// Indicate that we will set the axis numbers in the content structs ourselves.
	// Setting FirstGoAcross is thus not needed, but is done for completeness.
	s.useProvAxesPos =1					// 1 means we will use our own axis numbers
	s.FirstGoAcross = 1					// FirstGoAcross is not used, because useProvAxesPos is 1
	// The numbers of left and bottom axes to make are set from variables passed to GUIPHist_test itself
	s.nLaxes = nY
	s.nBaxes = nX
	// Specifications for axis font and size. Used for axis labels.
	s.AxisFont = "Arial"
	s.axisFontSize = 10
	// Percentage of the total width/height of the graph used to separate adjacent axes.
	s.spacerPercentX = 3						// 3% of graph width will separate B_0 and B_1, B_1 and B_2, etc.
	s.spacerPercentY = 10					// Spacing between left axes is bigger to make room for titles
	// Setting of minimum and maximum for axis ranges for left and bottom axes
	s.xScalType = kGUIPHistProvideScal	// We will provide the minimum and the maximum for the bottom axes
	s.yScalType = kGUIPHistFullScal		// GUIPHist will set axis ranges to minimum and maximum of all data 
	s.minX = 0									// for all bottom axes, min value will be 0
	s.MaxX = 10									// for all bottoma axes, max value will be 10
	s.axesOffsetX =15							// This value will be ignored, because using fullScale for left
	s.axesOffsetY =5							// This value will be ignored, because using fullScale for left
	// Specifications for font and size of the optional title that can be given to each plot. 
	s.TitleFont = "Times New Roman"
	s.titleFontSize = 12
	s.Frame = kGUIPHistNoFrame				// No frame will be drawn around each plot. This is the default.
	// Make some test data. make nX * nY 1D waves, and fill each one with some random noise, the average values of
	// which increase with each wave made. Scale each wave from 0 to 10 seconds in X. Use SetScale d to give a data
	// unit for making nice Y axis labels.
	string savedFolder = GetDataFolder (1)
	NewDataFolder/o/S root:GUIPHistTest
	variable iHist, nHists = (nx * nY)
	for (iHist =0; iHist < nHists; iHist +=1) 
		make/o/n = 100 $"w_" + Num2Str (iHist)
		WAVE wHist = $"w_" + Num2Str (iHist)
		setscale/I x 0, 10, "s", wHist
		setscale d  0,0, "W", wHist
		wHist = (enoise (1e-03) + 1e-03)* (iHist + 1)/(iHist + nHists)
		WAVE cs.userWaves [0] = wHist
	endfor
	// Fill the array portions of the Hist struct, including the content structs. We only need to make one content
	// struct, and copy it to the correct place in the array of content structs.
	variable iy, ix
	for (iHist =0, iy = 0; iy < ny; iY +=1)  // iterate through all the left axes
		// In array of left axes legends, set this legend to some fanciful label reflecting left axis number
		s. lAxesLegends[iy] = "Day " + Num2Str (iY) + " Power (\\U)"
		// In the content struct, set the left axis number for this left axis (as we are setting them ourselves)
		cs.lAxis = iy
		// For each left axis,Iterate through all the bottom axes
		for (iX =0; iX < nX; iX +=1, iHist +=1) 
			//  In the array of bottom axes legends, set this legend to some fanciful label reflecting bottom
			// axis number. We only have to do this once, so only do on the first iteration of iY
			if (iY ==0)
				s. bAxesLegends[ix] = "Run " + Num2Str (ix) + " Time (\\U)"
			endif
			// In the content struct, set the bottom axis number for this bottom axis
			cs.BAxis = ix
			// Set the title for this plot to a string that reflects the number of the plot
			cs.histTitle = "Hist " + Num2Str (iHist)
			//	Each plot will contain one wave. Set content struct to reflect this
			cs.nUserWaves = 1
			// Set first wave reference in array to one of the waves made earlier
			WAVE cs.userWaves [0] =  $"w_" + Num2Str (iHist)
			// We use no strings or variables
			cs.nUserStrings = 0
			cs.nUserVariables = 0
			// we use no global strings or global variables. 
			cs.nUserGlobalVars =0
			cs.nUserGlobalStrs = 0
			// Copy the content struct to correct place in array of content structs
			s.contentStructs [iHist] = cs
		endfor // end of loop through ix
	endfor  // end of loop through iy
	// Call GUIPHist with the structure that we filled
	GUIPHist (s)
	setdatafolder $savedFolder  // reset datafolder to saved folder
end

//***********************************************************************************	
// A test function that demonstrates appending to GUIPHist, to get around the 100 plot limit
// Last modified 2013/03/20 by Jamie Boyd
Function GUIPHistAppend_Test (nX, nY)
	variable nX   	// number of bottom (horizontal) axes
	variable nY   // number of left (vertical) axes
	
	// we will divide y dimension into 2, and append the 2nd half to same graph
	variable nY_first = ceil(nY/2)
	variable nY_second = nY - nY_first
	// Declare a Hist Struct and a content struct for plotting with GUIPHist
	STRUCT GUIPHistStruct s
	STRUCT GUIPHistCS cs
	// fill "non-array" parts of GUIPHistStruct s for first run
	// i.e., those that do not need to be filled inside of a loop
	s.isAppending = 0						// making a new plot, not appending
	s.graphName = "GUIPHist"			// Requested name of the new graph will be GUIPHist
	s.graphTitle = "GUIP Test Graph"	// Title of the new graph will be "GUIP Test Graph"
	s.killBehavior = 0					// new graph will kill with no dialog
	s.nHists= nY_first * nX				// The total number of plots is nX times the first half of nY
	// Make a function reference to the user function to add content, GUIPHist_test_Add (see below)
	FUNCREF GUIPHistAddProto s.addContent = GUIPHist_test_Add
	// Define onscreen position for window for new graph. Here, left =10 and right = 600,
	// top = 50, and bottom = 350, so window size = 590 x 300
	s.wLeft = 10
	s.wTop = 50
	s.wRight = 600
	s.wBottom = 350
	// Use auto margins. This is the default, so explicitly setting them is not needed
	s.margL = 0
	s.margT = 0
	s.margR = 0
	s.margB = 0
	// Indicate that we will set the axis numbers in the content structs ourselves.
	// Setting FirstGoAcross is thus not needed, but is done for completeness.
	s.useProvAxesPos =1					// 1 means we will use our own axis numbers
	s.FirstGoAcross = 1					// FirstGoAcross is not used, because useProvAxesPos is 1
	// The numbers of left and bottom axes to make are set from variables passed to GUIPHist_test itself
	s.nLaxes = nY_first
	s.nBaxes = nX
	// Specifications for axis font and size. Used for axis labels.
	s.AxisFont = "Arial"
	s.axisFontSize = 10
	// Percentage of the total width/height of the graph used to separate adjacent axes.
	s.spacerPercentX = 0.1						// 3% of graph width will separate B_0 and B_1, B_1 and B_2, etc.
	s.spacerPercentY = 2					// Spacing between left axes is bigger to make room for titles
	// Setting of minimum and maximum for axis ranges for left and bottom axes
	s.xScalType = kGUIPHistProvideScal	// We will provide the minimum and the maximum for the bottom axes
	s.yScalType = kGUIPHistFullScal		// GUIPHist will set axis ranges to minimum and maximum of all data 
	s.minX = 0									// for all bottom axes, min value will be 0
	s.MaxX = 10									// for all bottoma axes, max value will be 10
	s.axesOffsetX = 0							// This value will be ignored, because using fullScale for left
	s.axesOffsetY = 0							// This value will be ignored, because using fullScale for left
	// Specifications for font and size of the optional title that can be given to each plot. 
	s.TitleFont = "Times New Roman"
	s.titleFontSize = 12
	s.Frame = kGUIPHistNoFrame				// No frame will be drawn around each plot. This is the default.
	// Make some test data. make nX * nY 1D waves, and fill each one with some random noise, the average values of
	// which increase with each wave made. Scale each wave from 0 to 10 seconds in X. Use SetScale d to give a data
	// unit for making nice Y axis labels.
	string savedFolder = GetDataFolder (1)
	NewDataFolder/o/S root:GUIPHistTest
	variable iHist, nHistsTotal = (nx * nY)
	for (iHist =0; iHist < nHistsTotal; iHist +=1) 
		make/o/n = 100 $"w_" + Num2Str (iHist)
		WAVE wHist = $"w_" + Num2Str (iHist)
		setscale/I x 0, 10, "s", wHist
		setscale d  0,0, "W", wHist
		wHist = (enoise (1e-03) + 1e-03)* (iHist + 1)/(iHist + nHistsTotal)
		WAVE cs.userWaves [0] = wHist
	endfor
	// Fill the array portions of the Hist struct, including the content structs. We only need to make one content
	// struct, and copy it to the correct place in the array of content structs.
	variable iy, ix
	for (iHist =0, iy = 0; iy < nY_first; iY +=1)  // iterate through all the left axes
		// In array of left axes legends, set this legend to some fanciful label reflecting left axis number
		s. lAxesLegends[iy] = "(\\U)"
		// In the content struct, set the left axis number for this left axis (as we are setting them ourselves)
		cs.lAxis = iy
		// For each left axis,Iterate through all the bottom axes
		for (iX =0; iX < nX; iX +=1, iHist +=1) 
			//  In the array of bottom axes legends, set this legend to some fanciful label reflecting bottom
			// axis number. We only have to do this once, so only do on the first iteration of iY
			if (iY ==0)
				s. bAxesLegends[ix] =  "(\\U)"
			endif
			// In the content struct, set the bottom axis number for this bottom axis
			cs.BAxis = ix
			// Set the title for this plot to a string that reflects the number of the plot
			cs.histTitle = "Hist " + Num2Str (iHist)
			//	Each plot will contain one wave. Set content struct to reflect this
			cs.nUserWaves = 1
			// Set first wave reference in array to one of the waves made earlier
			WAVE cs.userWaves [0] =  $"w_" + Num2Str (iHist)
			// We use no strings or variables
			cs.nUserStrings = 0
			cs.nUserVariables = 0
			// we use no global strings or global variables. 
			cs.nUserGlobalVars =0
			cs.nUserGlobalStrs = 0
			// Copy the content struct to correct place in array of content structs
			s.contentStructs [iHist] = cs
		endfor // end of loop through ix
	endfor  // end of loop through iy
	// Call GUIPHist with the structure that we filled
	GUIPHist (s)
	// get ready for round 2
	// hist struct variables that need changing
	s.isAppending = 1
	s.nHists= nY_second * nX
	s.nLaxes = nY_second
	s.LaxisOffset = nY_first
	variable histOffset = nY_first * nX	
	for (ihist=0, iY =0;iy < ny_second; iY +=1)  // iterate through all the left axes
		// In array of left axes legends, set this legend to some fanciful label reflecting left axis number
		s. lAxesLegends[iy] =   "(\\U)"
		// In the content struct, set the left axis number for this left axis (as we are setting them ourselves)
		cs.lAxis = iy
		// For each left axis,Iterate through all the bottom axes
		for (iX =0; iX < nX; iX +=1, iHist +=1) 
			//  In the array of bottom axes legends, set this legend to some fanciful label reflecting bottom
			// axis number. We only have to do this once, so only do on the first iteration of iY
			if (iY ==0)
				s. bAxesLegends[ix] =  "(\\U)"
			endif
			// In the content struct, set the bottom axis number for this bottom axis
			cs.BAxis = ix
			// Set the title for this plot to a string that reflects the number of the plot
			cs.histTitle = "Hist " + Num2Str (iHist + histOffset)
			//	Each plot will contain one wave. Set content struct to reflect this
			cs.nUserWaves = 1
			// Set first wave reference in array to one of the waves made earlier
			WAVE cs.userWaves [0] =  $"w_" + Num2Str (iHist+ histOffset)
			// We use no strings or variables
			cs.nUserStrings = 0
			cs.nUserVariables = 0
			// we use no global strings or global variables. 
			cs.nUserGlobalVars =0
			cs.nUserGlobalStrs = 0
			// Copy the content struct to correct place in array of content structs
			s.contentStructs [iHist] = cs
		endfor // end of loop through ix
	endfor  // end of loop through iy
	// Call GUIPHist with the structure that we filled
	GUIPHist (s)
	setdatafolder $savedFolder  // reset datafolder to saved folder
end

//***********************************************************************************	
// The plotting function used by GUIPHist_test
// Last modified 2013/03/19 by Jamie Boyd
STATIC Function GUIPHist_test_Add (cs)
	STRUCT GUIPHistCS &cs
	variable iW
	// Although we only have one wave, we will iterate through the list of waves
	for (iw =0 ; iw < cs.nUserWaves; iw +=1)
		// Append the wave from the iw-th position in the array of user waves to the left and bottom axes
		// named in the axis Strings
		AppendToGraph/w=$cs.graphName/B=$cs.baxisStr/L=$cs.lAxisStr cs.userWaves [iw]
		// apply some simple formatting, in this case, change the plot mode to histogram bars and the plot
		// color to black. Note that using $NameOfWave(cs.userWaves [iw]) for the tracename will fail if multiple
		// waves with the same name (or copies of the same wave) are displayed on a graph.  
		ModifyGraph/w=$cs.graphName rgb ($NameOfWave(cs.userWaves [iw])) = (0,0,0)
		ModifyGraph/w=$cs.graphName mode($NameOfWave(cs.userWaves [iw]))=5,hbFill($NameOfWave(cs.userWaves [iw]))=2
	endfor
end
